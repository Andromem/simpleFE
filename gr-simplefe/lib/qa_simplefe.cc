/*
 * Copyright 2012 Free Software Foundation, Inc.
 *
 * This file was generated by gr_modtool, a tool from the GNU Radio framework
 * This file is a part of gr-simplefe
 *
 * GNU Radio is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * GNU Radio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GNU Radio; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * This class gathers together all the test cases for the gr-filter
 * directory into a single test suite.  As you create new test cases,
 * add them here.
 */

#include "qa_simplefe.h"
#include "ringbuf.h"
#include <complex>
#include "stdio.h"


class RingbufTest : public CppUnit::TestFixture
{
private:
    static const int data_size = 16;
    gr::simplefe::ring_buffer< std::complex<float> > *cplx_buf;
    std::complex<float> wdata[data_size*2];
    float rdata[data_size*4];

    gr::simplefe::ring_buffer<unsigned char> *byte_buf;
    unsigned char wdata2[data_size*4];
    std::complex<float> rdata2[data_size*2];
    
public:
    void setUp()
    {
        cplx_buf = new gr::simplefe::ring_buffer< std::complex<float> >(data_size);
        for (int i=0; i<data_size*2; i++){
            wdata[i] = std::complex<float>(i*1.0, i*2.0);
        }

        byte_buf = new gr::simplefe::ring_buffer<unsigned char>(data_size*2);
        for (int i=0; i<data_size*4; i++){
            wdata2[i] = i;
        }
    }

    void tearDown()
    {
        delete cplx_buf;
        delete byte_buf;
    }

    static int conv(void* dst, void* src, int src_len)
    {
        int dst_len = 0;
        std::complex<float> *s = static_cast<std::complex<float>*>(src);
		float *out = static_cast<float*>(dst);
        for (int i=0; i<src_len; i++){
            out[dst_len++] = s[i].real();
            out[dst_len++] = s[i].imag();
        }
        return dst_len*sizeof(float);
    }
    
    static int calc_size(int dst_len)
    {
        return dst_len/sizeof(std::complex<float>);
    }


    static int conv2(void* dst, void* src, int src_len)
    {
        int dst_len = 0;
        std::complex<float> *out = (std::complex<float>*)dst;
        unsigned char *in = (unsigned char*)src;
        
        for (int i=0; i<src_len; i+=2){
            out[dst_len++] = std::complex<float>(in[i]*1.0, in[i+1]*1.0);
        }
        return dst_len*sizeof(std::complex<float>);
    }

    static int calc_size2(int dst_len)
    {
        return dst_len*2;
    }
    
    
    void testSimpleReadWrite()
    {
        cplx_buf->write(&wdata[0], 16);

        cplx_buf->read(&rdata[0], 16*2*sizeof(float)
                       ,conv, calc_size
                       );


        for (int i=0; i<32; i+=2){
            float x = i/2*1.0;
            CPPUNIT_ASSERT_DOUBLES_EQUAL( rdata[i], x, 1e-6);
            CPPUNIT_ASSERT_DOUBLES_EQUAL( rdata[i+1],  x*2.0, 1e-6);
        }
    }

    void testReadWrite()
    {
        int pos = 0;
        //write 12
        cplx_buf->write(&wdata[0], 12); 
        //read 6
        pos = cplx_buf->read(&rdata[0], 6*2*sizeof(float)
                             ,conv, calc_size
                             );
        //write 10 
        cplx_buf->write(&wdata[0], 10);
        // read 16
        cplx_buf->read(&rdata[6*2], 16*2*sizeof(float)
                       ,conv, calc_size
                       );

        for (int i=0; i<(16+6)*2; i+=2){
            float x = (i%(12*2))/2*1.0;
            //printf("%.3f, %.3f\n", rdata[i], rdata[i+1]);

            CPPUNIT_ASSERT_DOUBLES_EQUAL( rdata[i], x, 1e-6);
            CPPUNIT_ASSERT_DOUBLES_EQUAL( rdata[i+1],  x*2.0, 1e-6);
        }
    }


    void testReadWrite2()
    {
        int pos = 0;
        //write 24
        byte_buf->write(&wdata2[0], 24); 
        //read 6
        pos = byte_buf->read(&rdata2[0], 6,
                             conv2, calc_size2
                             );
        //write 20
        byte_buf->write(&wdata2[0], 20);
        // read 16
        byte_buf->read(&rdata2[6], 16,
                       conv2, calc_size2
                       );

        for (int i=0, j=0; i<(16+6); i++, j+=2){
            //printf("%.2f, %.2f\n", rdata2[i].real(), rdata2[i].imag());
            CPPUNIT_ASSERT( (int)rdata2[i].real() == j%24 );
            CPPUNIT_ASSERT( (int)rdata2[i].imag() == (j+1)%24 );
        }
    }
    
};

    
CppUnit::TestSuite *
qa_simplefe::suite()
{
  CppUnit::TestSuite *s = new CppUnit::TestSuite("simplefe");
  s->addTest(new CppUnit::TestCaller<RingbufTest>("testSimpleReadWrite",
                                                   &RingbufTest::testSimpleReadWrite)
             );
  s->addTest(new CppUnit::TestCaller<RingbufTest>("testReadWrite",
                                                   &RingbufTest::testReadWrite)
             );
  s->addTest(new CppUnit::TestCaller<RingbufTest>("testReadWrite2",
                                                   &RingbufTest::testReadWrite2)
             );
  
  return s;
}


